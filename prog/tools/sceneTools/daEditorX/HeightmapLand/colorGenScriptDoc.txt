

*** Задача скрипта и термины

Скрипт используется для генерации цветов поверхности и типов ее детализации по карте высот (heightmap).
Для каждой точки карты вызывается функция скрипта, которая используя доступные данные
о карте (высоту, наклон, кривизну, маски и т.д.) определяет в этой точке цвет и тип детализации.

Цвет - цвет поверхности, без освещения (diffuse), в скрипте хранится как 24-битный цвет,
по 8 бит на компоненту.

Тип детализации, он же номер текстуры детализации - определяет какой фактурой будет
детализоваться поверхность вблизи.

Цвет и тип детализации пакуются вместе в 32-битное значение (int), чтобы с ними было
просто и быстро работать. В описании функций "цвет" употребляется в основном в этом смысле,
как объединение цвета и типа детализации.
(Фактически, для хранения типа используется альфа 32-битного цвета.)



*** Структура и параметры скрипта

В скрипте должны быть две функции: getParamsList и getGenerator.


Первая возвращает список параметров, к примеру:

function getParamsList()
{
  local list=
  [
    {name= "fullGrassAngle", type="real", value=30},
    {name="startGrassAngle", type="real", value=45},

    {name="grassTexture", type="image", value="grass"},
    {name="dissolveMap", type="image", value="noise1"},

    {name="dirtTexture", type="image", value="dirtMap"},
  ];
  return list;
}

Список - массив таблиц, каждая таблица описывает один параметр.

В каждой таблице (каждом описании параметра) должны быть:
name="..." - имя параметра,
type="..." - тип параметра.
value - не обязательно, это значение параметра по умолчанию.
Для типа "image" value представляет из себя таблицу со следующими полями (каждое из них необязательно):
"imageName"                    - string
"mappingType", "detailType"    - int
"tileX", "tileY", "offsetX", "offsetY"         - real
"clampU", "clampV", "flipU", "flipV", "swapUV" - bool


Типы параметров:

"int" или "integer" - целочисленный.
"real" или "float" - вещественное число.
"color" - 32-битный цвет.
"image" - изображение или маска.


Параметры из этого списка можно настраивать в панели редактора, их значения сохраняются в проекте.
Перед вызовом функции getGenerator значения параметров выставляются в скрипт как глобальные переменные.


Вторая функция - getGenerator - должна возвращать функцию, генерирующую цвета и типы детализации.
Пример:

function getGenerator()
{
  local  fullGrassCos=cos(degToRad( fullGrassAngle));
  local startGrassCos=cos(degToRad(startGrassAngle));

  return function() : (fullGrassCos, startGrassCos)
  {
    local normalY=getNormalY();

    // base 'dirt' / 'stone'
    local result=sampleImage(dirtTexture);

    // add grass by angle
    result=dissolveOver(result,
      sampleImage(grassTexture),
      smoothStep( calcBlendK(startGrassCos, fullGrassCos, normalY) ),
      sampleMask(dissolveMap));

    return result;
  }
}

Как видно, функция getGenerator предрасчитывает значения fullGrassCos и startGrassCos, которые
потом будут использоваться в вычислениях и передаются в функцию генерации как "свободные переменные"
(free variables, конструкция ": (...)", см. описание языка Squirrel).
Этого можно и не делать, вычисляя их каждый раз, но так код понятнее и работает быстрее
(см. раздел про оптимизацию скрипта).

Функция генерации возвращает 32-битное значение (int), содержащее цвет и тип детализации.



*** Описание функций, доступных скрипту

Кроме описанных, доступны также функции стандартных библиотек Squirrel (например, математические).


getNormalX()
getNormalY()
getNormalZ()

Возвращают различные компоненты вектора нормали.
Наиболее интересна getNormalY(), т.к. фактически это косинус угла наклона поверхности
относительно горизонтальной плоскости.



getHeight()

Возвращает абсолютную высоту поверхности, в мировых координатах.



getCurvature()

Возвращает кривизну поверхности. 0 - плоская, положительные значения - вогнутая, отрицательные - выпуклая.



getHeightMapX()
getHeightMapZ()

Возвращают координаты текущей точки (float) в сетке heightmap-а.



getHeightMapSizeX()
getHeightMapSizeZ()

Возвращают размеры сетки heightmap-а (int).



makeColor(red, green, blue, type)
  red (int) - красный, от 0 до 255 (значения больше или меньше обрезаются до крайних).
green (int) - зеленый, от 0 до 255 (значения больше или меньше обрезаются до крайних).
 blue (int) -   синий, от 0 до 255 (значения больше или меньше обрезаются до крайних).
 type (int) - тип детализации, он же номер текстуры детализации.

Собирает цвет из компонент и возвращает его (как int).



setType(color, type)
color (int) - цвет + тип.
 type (int) - новое значение типа детализации.

Заменяет значение типа на новое и возвращает новый "цвет + тип" с этим значением.



getType(color)
color (int) - цвет + тип.

Возвращает тип детализации (int).



blendColors(color1, color2, t)
color1 (int) - первый цвет.
color2 (int) - второй цвет.
   t (float) - параметр смещивания, от 0 (первый цвет) до 1 (второй цвет).

Интерполирует цвет от первого до второго по указанному параметру t.
Тип берется из color1, если t<=0.5, иначе из color2.

См. также dissolveOver.



mulColors(color1, color2)
color1 (int) - первый цвет.
color2 (int) - второй цвет.

Перемножает цвета, возвращает полученный цвет.
Тип берется из color1.



mulColors2x(color1, color2)
color1 (int) - первый цвет.
color2 (int) - второй цвет.

Перемножает цвета и умножает результат на 2, возвращает полученный цвет.
Тип берется из color1.



dissolveOver(color1, color2, t, mask)
color1 (int) - первый цвет.
color2 (int) - второй цвет.
   t (float) - параметр смещивания, от 0 (первый цвет) до 1 (второй цвет).
mask (float) - значение маски dissolve в текущей точке.

Выбирает и возвращает либо первый, либо второй цвет, в зависимости от значений t и mask:
Если t<=0 - первый.
Если t>=1 - второй.
Если t<mask - первый, иначе второй.

Пример использования:
  result=dissolveOver(result, sampleImage(snowTexture), t, sampleMask(dissolveMap));

См. также blendColors, sampleMask.



calcBlendK(value0, value1, v)
value0 (float) - значение, при котором возвращается 0.
value1 (float) - значение, при котором возвращается 1.
     v (float) - "текущее" значение.

Вспомогательная функция, возвращает значение от 0 до 1 (float).
Если v находится между value0 и value1, возвращается среднее между 0 и 1 значение.
Если v==value0 или выходит "за край" - возвращается 0.
Если v==value1 или выходит "за край" - возвращается 1.

Значения value0 и value1 могут быть любыми, не обязательно по возрастанию.

Пример использования:
  t=calcBlendK(startGrassCos, fullGrassCos, normalY);

См. также blendColors, dissolveOver, smoothStep.



smoothStep(t)
t (float) - параметр (от 0 до 1).

"Сглаживает" значение параметра, часто используется вместе с calcBlendK.
Если t<=0 возвращает 0.
Если t>=1 возвращает 1.
Иначе возвращает значение от 0 до 1, по формуле кубического сплайна (3-2*t)*t*t.

Особенности этого сплайна:
При t==0.0 -> 0.0
При t==0.5 -> 0.5
При t==1.0 -> 1.0
Симметричен относительно 0.5, производные на концах (0 и 1) равны нулю.



sampleImage(image)
sampleImageAt(image, u, v)
image - изображение.
u, v (float) - координаты в текстуре (маппинг).

Возвращает значение цвета (и типа детализации) из указанного изображения.
В случае sampleImage используется маппинг, указанный в настройках изображения.
В случае sampleImageAt используются только значения настроек flip, swapUV и clamp.



sampleMask(image)
sampleMaskAt(image, u, v)
image - изображение.
u, v (float) - координаты в текстуре (маппинг).

Возвращает значение маски (float от 0 до 1) из изображения, используя яркость цвета.
См. sampleImage, sampleImageAt.

sampleMaskAlpha(image)
sampleMaskRed(image)
sampleMaskGreen(image)
sampleMaskBlue(image)

sampleMaskAlphaAt(image, u, v)
sampleMaskRedAt(image, u, v)
sampleMaskGreenAt(image, u, v)
sampleMaskBlueAt(image, u, v)

Аналогично sampleMask и sampleMaskAt, но возвращает значение маски в одном канале



*** Оптимизация скрипта

Используйте локальные переменные (local) где возможно, т.к. обращение к ним происходит
существенно быстрее, чем к глобальным.

В функции генерации запишите все используемые глобальные переменные и функции в free variables
(конструкция function() : (список свободных переменных) { код } - см. описание языка Squirrel).
Значения свободных переменных (free variables) сохраняются один раз при создании функции и внутри
нее обращения к ним так же быстры, как к локальным переменным.
Функция getGenerator возвращает функцию как раз для этого, чтобы можно было сохранить значения
глобальных переменных (параметров скрипта прежде всего) в этот момент, перед генерацией карты.

Запишите в свободные переменные в том числе используемые функции скрипта, вроде getNormalY или sampleImage.
Если запишите лишнего - не страшно, скорость генерации от этого скорее всего не изменится.
А вот если не запишите - будет обращение к глобальной переменной, которое заметно медленней.

Выносите из функции генерации значения, которые константны для всей карты, их можно предвычислить
в функции getGenerator (которая при генерации вызывается только один раз) и передать в функцию
генерации как free variables.
