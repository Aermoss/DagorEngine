
#ifndef __DOLPHIN__DOLPHIN_H

#define __DOLPHIN__DOLPHIN_H

#define DOLPHIN_VERSION "0.2.3"
#define DOLPHIN_RELEASE_DATE "5 March, 2001"
#define SHORT_COPYRIGHT_NOTICE "Dolphin " DOLPHIN_VERSION ", a lexical analyzer generator. " "(C) Alexander Okhotin, 1999-2001.\n"
#define LONG_COPYRIGHT_NOTICE "Dolphin " DOLPHIN_VERSION ", a lexical analyzer generator.\n" "Copyright (C) Alexander Okhotin <whale@aha.ru>, 1999-2001.\n"
#define COPYRIGHT_NOTICE_FOR_GENERATED_FILES "\t\x22" "A lexical analyzer generated by Dolphin " DOLPHIN_VERSION " (" DOLPHIN_RELEASE_DATE ").\\n\x22\n" "\t\x22" "Dolphin is (C) Alexander Okhotin <whale@aha.ru>, 1999-2001.\\n\x22"
#define FIRST_LINE_FOR_GENERATED_FILES "\n/* A lexical analyzer generated by Dolphin */\n"
#define COMMAND_LINE_SYNTAX "Command line syntax: dolphin filename.dlp\n"

#if '\xff'<'\x0'
	#error This program requires char to be unsigned.
#endif

#include "assert.h"

#include <string.h>
#include <vector>
#include <set>
#include <map>
#include <string>

#include "parser.h"
#include "matrix.h"
#include "nfa-to-dfa.h"
#include "utilities.h"
#include "variables.h"
#include "charset.h"
#include "intervals.h"

struct NonterminalData
{
	const char *name;
	std::vector<Whale::NonterminalRuleStatement *> rules;
	
	// if it is _directly_ used in some IN expression
	bool is_used_in_IN_expressions;
	std::vector<Whale::Terminal *> where_it_is_used_in_IN_expressions;
	
	// if the definition of this nonterminal contains some operation
	// (like concatenation) that renders it unusable in IN expressions.
	bool can_be_used_in_IN_expressions;
	std::vector<Whale::Terminal *> locations_of_offending_rules;
	
	// if this nonterminal can generate only one-character strings and if
	// all such derivations have already been precalculated, then
	// then "expanded" points to the set of those symbols, otherwise ==NULL.
	UnionOfIntervals<int> *expanded;
	
	bool expression_length_calculated;
	int expression_length;
	
	NonterminalData()
	{
		name=NULL;
		is_used_in_IN_expressions=false;
		can_be_used_in_IN_expressions=true;
	//	set_is_calculated=false;
		expanded=NULL;
		expression_length_calculated=false;
	}
};

struct StartConditionData
{
	const char *name;
	Whale::Terminal *declaration;
	
	StartConditionData()
	{
		name=NULL;
		declaration=NULL;
	}
};

struct ActionData
{
	bool is_special; // true for 'eof' and 'error' expressions.
	
	Whale::NonterminalActionStatement *declaration;
	std::set<int> start_condition_numbers;
	int recognized_expression_number;
	
	ActionData()
	{
		is_special=false;
		declaration=NULL;
	}
};

struct RecognizedExpressionData
{
	bool is_special; // true for 'eof' and 'error' expressions.
	
	Whale::NonterminalExpression *expr, *lookahead;
	char *in_serialized_form;
	
	// expr (final state) ==> ...
	//	or
	// expr1 (intermediate state) / expr2 (final state) ==> ...
	int intermediate_nfa_state, final_nfa_state;
	std::set<int> intermediate_dfa_states, dfa_states;
	
	std::vector<int> action_numbers;
	
	// for each start condition. -1 means none.
	std::vector<int> start_condition_to_action_number;
	
	// if lookahead!=NULL
	int lookahead_length; // -1 if its length varies
	int lookahead_eof; // -1 not at eof, 0 - doesn't matter, 1 - at the eof
	
	RecognizedExpressionData()
	{
		is_special=false;
		expr=NULL;
		lookahead=NULL;
		in_serialized_form=NULL;
		intermediate_nfa_state=-1;
		final_nfa_state=-1;
		lookahead_length=0;
		lookahead_eof=0;
	}
};

struct AssignmentData
{
	Whale::NonterminalOptionStatement *declaration;
	
	enum ValueType {VALUE_TRUE, VALUE_FALSE, VALUE_ID, VALUE_STRING,
		VALUE_NUMBER, VALUE_HEX_NUMBER, VALUE_CODE};
	std::vector<std::pair<const char *, ValueType> > values;
	
	AssignmentData()
	{
		declaration=NULL;
	}
};

// information about a single derivation path in the grammar
struct PathData
{
	enum TransitionType { RIGHT=0, NORMAL=1, IN_EXPRESSION };
	
	std::vector<std::pair<Whale::Terminal *, TransitionType> > v;
	TransitionType worst; // should be equal to max(v[i].second)
};

inline std::ostream &operator <<(std::ostream &os, PathData::TransitionType &t)
{
	if(t==PathData::RIGHT)
		os << "Right";
	else if(t==PathData::NORMAL)
		os << "Normal";
	else if(t==PathData::IN_EXPRESSION)
		os << "IN expression";
	else
		assert(false);
	return os;
}

class DolphinData
{
public:
    static DolphinData data;
	CharacterSet charset;
	
	std::vector<NonterminalData> nonterminals;
	std::vector<StartConditionData> start_conditions;
	
	std::vector<ActionData> actions;
	std::vector<RecognizedExpressionData> recognized_expressions;
	std::map<const char *, int, NullTerminatedStringCompare> recognized_expression_search;
	
	matrix<PathData> derivation_paths;
	
	NFA nfa;
	DFA dfa;
	std::vector<bool> live_states_in_dfa; // see nfa-to-dfa
	DFA::Partition dfa_partition;
	
	// action_vectors_in_state_groups[i][j]=k, k!=-1 means that in state
	// group i and start condition j action k should be executed.
	std::vector<std::vector<int> > action_vectors_in_state_groups;
	
	// expr1 (this state) / expr2 ==> ...
	std::vector<bool> lookahead_states_in_final_dfa;
	
	std::vector<int> symbol_to_symbol_class;
	int number_of_symbol_classes;
	matrix<int> final_transition_table;
	
        std::map<const char *, AssignmentData, NullTerminatedStringCompare> assignments;
	Variables variables;
	
	std::string file_name;
	
	// *** remove these lines together with 'return' and 'skip' keywords ***
	bool return_keywords_used;
	bool skip_keywords_used;
	
	struct Tables
	{
		// Transition table: The first layer of compression.
		std::vector<int> state_to_layer1; // or -1 for null lines.
		std::vector<int> layer1_to_state; // to one of those states.
		int null_line_number;
		
		// Transition table: The second layer of compression.
		std::vector<int> layer1_to_layer2;
		std::vector<int> layer2_to_layer1;
		std::vector<int> layer1_to_exception_location; // -1 for no exception.
		std::vector<std::vector<int> > layer1_to_exception_data;
		
		// Transition table: final table of lines, either layer 1 or 2.
		std::vector<int> line_to_offset_in_table_of_lines;
		std::vector<int> compressed_table_of_lines;
		
		// Indices in table of intermediate (lookahead) states.
		//	Here: for each recognized expression;
		//	In generated file: for each action.
		std::vector<int> offset_in_table_of_lookahead_states;
		std::vector<int> number_of_lookahead_states;
		
		// The table of intermediate (lookahead) states.
		std::vector<int> compressed_table_of_lookahead_states;
		
		Tables() { null_line_number=-1; }
	};
	
	Tables tables;
	
	int find_nonterminal(const char *s)
	{
		for(int i=0; i<nonterminals.size(); i++)
			if(!strcmp(s, nonterminals[i].name))
				return i;
		return -1;
	}
	int find_start_condition(const char *s)
	{
		for(int i=0; i<start_conditions.size(); i++)
			if(!strcmp(s, start_conditions[i].name))
				return i;
		return -1;
	}
	
	DolphinData();
};

inline int sgn(int x)
{
	return (x<0 ? -1 : (!x ? 0 : 1));
}

#endif
