
/*
	SLR1 tables builder.
	(C) Vladimir Prus <ghost@cs.msu.su>, 2000

	History
		Sep 8, 2000 - started
		Sep 9, 2000 - LR0 seems to work

	Times:

		23:03 -- 23:40
		16:12 -- 17:09
		21:26 -- 23:00
		20:33 -- 21:00

	Documentation:
		1. DottedRule and State.
			These two classes correspond to notions from LR parsing theory.
			Their definition is very clear. The only point to note is that
			DottedRule keeps pointer to rule instead of it number, which
			makes possible implementing several functions as methods of
			DottedRule.
		2. States
			States are numbered and it's most reasonable to store them in
			a vector. However, fast probe for existance is needed. For that,
			a special data structure call 'numbered_set' has been devised.
			I think that it closely approaches the higher bound on speed.
			See the header file for details.
		3. Closure/transition computation
			Note that
				(i)	Closure need not be stored
				(ii) For each kernel rule, closure generated depends only
					on active symbol of that rule.
			So, we can precompute closures generated by each nonterminal.
			Going further, we define 'raw_transition' as a pair
			(Symbol, DottedRule). Having precomputed raw transitions for
			each nonterminal, we can merge raw transitions generated by
			every active symbol of kernel rules with those created by kernel
			rules themself, sort the resulting set, and start creating real
			transitions in linear time.								
		4. Vector memory management.
			STL implementations differ in memory management. In particular,
			Rogue Wave STL vector will grab 1K of memory on the first insert.
			Since number of items is usually small in LR0 builder, it leads to
			a lot of wasted memory, which can cause poor cache behaviour and
			even swapping. Workaround is simple: call reserve(1) before
			inserting any items in vector.
		
*/

// added by AO:
#ifndef LR0_SUPPRESS_PROFILING
#define LR0_SUPPRESS_PROFILING
#endif
//#define LR0_DEBUG_PHASES

#define _RWSTD_BOUNDS_CHECKING

#include "whale.h"
#include "nstl/numbered_set.h"
#include "nstl/algorithm_extensions.h"
//#include "nstl/stl.h"
//#include "nstl/stl_extra.h"
#include "utilities.h"

//#include "nstl/traditional_functors.h"

#include <fstream>

#ifndef LR0_SUPPRESS_PROFILING
	#include "profiling.h"
#endif

using namespace std;
using namespace rel_ops;


struct DottedRule
{
	typedef RuleData Rule;

	const Rule* _rule;
	const Rule& rule() const { return *_rule; }
	int dot;


	DottedRule(const Rule& rule, int dot) : _rule(&rule), dot(dot) {}

	bool reducing() const {
		return dot == rule().body.size();
	}

	bool accepting() const {
		return reducing() && rule().nn == 0;
	}

	DottedRule advance_dot() const {
		return DottedRule(rule(), dot + 1);
	}

	SymbolNumber active_symbol() const {
		return rule().body[dot];
	}

	bool operator<(const DottedRule& another) const
	{
		return (this->_rule < another._rule) ||
				((this->_rule == another._rule) && this->dot < another.dot);
	}

	bool operator==(const DottedRule& another) const
	{
		return this->_rule == another._rule &&
				this->dot == another.dot;
	}

};

ostream& operator<<(ostream& os, const SymbolNumber& n)
{
	if (n.is_terminal()) os << WhaleData::data.terminals[n.terminal_number()].name;
	if (n.is_nonterminal()) os << WhaleData::data.nonterminals[n.nonterminal_number()].name;
	return os;
}

ostream &operator <<(ostream &os, const DottedRule &dr)
{
	const RuleData &rule = dr.rule();

	os << "[" << WhaleData::data.nonterminals[rule.nn].name << " -> ";
	if(rule.body.size())
	{
		for(int i=0; i<rule.body.size(); i++)
		{
			if(i) os << " ";
			if(i== dr.dot) os << ". ";
			os << WhaleData::data.symbol_name(rule.body[i]);
		}
		if(dr.dot==rule.body.size()) os << " .";
	}
	else
		os << ".";
	
	os << "]";
	
	return os;
}


struct State
{
	// FIXME: vector uses memory inefficiently
	vector<DottedRule> rules;
	vector<int> reduces;

	State() {};
	State(const vector<DottedRule>& rules_)
		: rules(rules_) // Dirty!
	{
		reduces.reserve(1);
		rules.reserve(1);
		make_set(this->rules);
	}

	bool operator==(const State& another) const {
		return rules == another.rules;
	}
};

template<>
struct hash<State>
{
	size_t operator()(const State& s)
	{
		// FIXME : to something more smart
		size_t h(0);
		for (size_t i = 0; i < s.rules.size(); ++i)
			h += (size_t(s.rules[i]._rule) + size_t(s.rules[i].dot << 25));
		return h;
	}
};



class SLR1Builder
{
public:
	numbered_set<State> states;

	typedef vector< pair<SymbolNumber, DottedRule> > raw_transitions_t;


	vector<raw_transitions_t> precomputed_transitions;
	vector< vector<int> > precomputed_reduces;

	// auxillary
	map<int, vector<int> > rule_4_nonterminal;


	SLR1Builder()
	{
	#ifdef LR0_DEBUG_PHASES
		cout << "SLR1Builder: precomputing transitions...";
	#endif

		{
	#ifndef LR0_SUPPRESS_PROFILING
		ticks_keeper tk("precompute");
	#endif
		precompute_transitions();
	#ifdef LR0_DEBUG_PHASES
		cout << "done\n";
	#endif
		}

		{
	#ifndef LR0_SUPPRESS_PROFILING
		ticks_keeper tk("build");
	#endif
		states.insert(State(vector<DottedRule>(1, DottedRule(WhaleData::data.rules[0], 0))));

		vector< pair<SymbolNumber, DottedRule> > raw_transitions;
		vector< int > reduces;

		for (size_t s = 0; s < states.size(); ++s) {
			
			raw_transitions.clear();
			reduces.clear();

			find_transitions_and_reduces(s, raw_transitions, reduces);
			record_transitions(s, raw_transitions);
			record_reduces(s, reduces);
		}
		}
		
		// added by AO:
		cout << WhaleData::data.lr_automaton.states.size() << " SLR(1) states.\n";
		
		{
	#ifndef LR0_SUPPRESS_PROFILING
		ticks_keeper tk("resolve_conflicts");
	#endif
		resolve_conflicts();
		}
	}	

	void resolve_conflicts();
		void record_reduce(size_t state, const vector<int>& rules, size_t l);
		void record_reduce(size_t state, size_t rule);


	void find_transitions_and_reduces(size_t s,
					vector< pair<SymbolNumber, DottedRule> >&transitions,
					vector<int>& reduces)								
	{
		State& state = states[s];

		for (vector<DottedRule>::iterator i = state.rules.begin(); i != state.rules.end(); ++i)
			if (i->reducing()) {
				int rule_no = i->_rule - WhaleData::data.rules.data();
				//distance(WhaleData::data.rules.cbegin(), 
				//	vector<RuleData>::const_iterator(i->_rule));
				reduces.push_back(rule_no);
			} else {
				SymbolNumber n = i->active_symbol();
				transitions.push_back(m2(n, i->advance_dot()));
				if (n.is_nonterminal()) {
					append_transitions_owning_to_closure(n, transitions);
					append_reduces_owning_to_closure(n, reduces);
				}
			}
	}

	void record_transitions(size_t s, vector< pair<SymbolNumber, DottedRule> >& t)
	{
		make_set(t);		

		assert(s == WhaleData::data.lr_automaton.states.size());
		WhaleData::data.lr_automaton.states.push_back(LRAutomaton::State());
		LRAutomaton::State &final_state=WhaleData::data.lr_automaton.states[s];
		
		final_state.action_table.resize(WhaleData::data.terminals.size());
		final_state.goto_table.resize(WhaleData::data.nonterminals.size());
		
		// AO (25 Feb 2001) fixed an error with random initialization:
		fill(final_state.action_table.begin(), final_state.action_table.end(), LRAction::error().get_n());
		fill(final_state.goto_table.begin(), final_state.goto_table.end(), -1);
		
		raw_transitions_t::iterator i, j, k;

		for (i = t.begin(); i != t.end(); i = j) {

			for (j = i; j != t.end() && j->first == i->first; ++j);

			State s;
			for (k = i; k != j; ++k) s.rules.push_back(k->second);	


			int target = states.index_of(s);

			if (i->first.is_terminal())
				final_state.action_table[i->first.terminal_number()] =
					LRAction::shift(target).get_n();
			else
				final_state.goto_table[i->first.nonterminal_number()] =
					target;
		}
	}

	void record_reduces(size_t s, vector<int> &r)
	{
		copy(r, back_inserter(states[s].reduces));
	}

	/* For each nonterminal, creates a set of transitions that it will
		yield after closure and records it for future use
	*/
	void precompute_transitions()
	{

		for (size_t i = 0; i < WhaleData::data.rules.size(); ++i)
			rule_4_nonterminal[WhaleData::data.rules[i].nn].push_back(i);

		for (size_t i = 0; i < WhaleData::data.nonterminals.size(); ++i)
			precompute_transitions(i);
	}
		
	void precompute_transitions(size_t i) {
			
	// Transition due to closure of this nonterminal
		vector< pair<SymbolNumber, DottedRule> > t;
		// Reduces due to closure of this nonterminal
		vector< int > r;

		// This may be inefficient, but who cares HERE?
		numbered_set<int> nonterminals_in_closure;
		nonterminals_in_closure.insert(i);

		for(size_t j = 0; j < nonterminals_in_closure.size(); ++j) {

			int nn = nonterminals_in_closure[j];

			if (nn < i) {
				SymbolNumber n = SymbolNumber::for_nonterminal(nn);
				append_transitions_owning_to_closure(n, t);
				append_reduces_owning_to_closure(n, r);
			}
			else {
					
				vector<int>& tr = rule_4_nonterminal[nn];
				for (size_t k = 0; k < tr.size(); ++k) {
						
					if (WhaleData::data.rules[tr[k]].body.empty()) r.push_back(tr[k]);
					else {
						
						SymbolNumber first = WhaleData::data.rules[tr[k]].body[0];
						t.push_back(m2(first, DottedRule(WhaleData::data.rules[tr[k]], 1)));
			
						if (first.is_nonterminal())
							nonterminals_in_closure.insert(first.nonterminal_number());
					}									
				}
			}
		}				

		make_set(t);
		make_set(r);

		precomputed_transitions.push_back(t);
		precomputed_reduces.push_back(r);
	}

	void append_transitions_owning_to_closure(SymbolNumber n,
				vector< pair<SymbolNumber, DottedRule> >& t)
	{
		copy(precomputed_transitions[n.nonterminal_number()],
			back_inserter(t));
	}

	void append_reduces_owning_to_closure(SymbolNumber n, vector<int> &r)
	{
		copy(precomputed_reduces[n.nonterminal_number()],
			back_inserter(r));

	}
};

void SLR1Builder::resolve_conflicts()
{
#ifdef LR0_DEBUG_PHASES
	cout << "Resolving conflicts (if any)...";
#endif
	for (size_t s = 0; s < states.size(); ++s) {

		vector<int>& reduces = states[s].reduces;

		if (reduces.size() == 0) continue;

		// FIXME: you know what	
		//if (reduces.size() == 1)
		//	record_reduce(s, reduces.front());
		if (reduces.size() >= 1) {

			// TODO: is some other algorithm possible?

			vector< pair<int, int> > lookahead_reduce;

			// TODO: follow must be stored as sorted vector
			for (size_t i = 0; i < reduces.size(); ++i) {

				int nn = WhaleData::data.rules[reduces[i]].nn;
				for (set<int>::iterator fi = WhaleData::data.nonterminals[nn].follow.begin();
					fi != WhaleData::data.nonterminals[nn].follow.end(); ++fi) {
						lookahead_reduce.push_back(m2(*fi, reduces[i]));
					}
			}
			
			make_set(lookahead_reduce); // !!! This was omitted in prior version
			
			for (size_t i = 0, j = 0; i < lookahead_reduce.size(); i = j) {
				
				for(; j < lookahead_reduce.size() &&
						lookahead_reduce[i].first == lookahead_reduce[j].first;
						++j);

				vector<int> these_reduces; these_reduces.reserve(1);
				for (size_t k = i; k < j; ++k)
					these_reduces.push_back(lookahead_reduce[k].second);

				record_reduce(s, these_reduces, lookahead_reduce[i].first);
			}
		}

	}

#ifdef LR0_DEBUG_PHASES
	cout << "done\n";
#endif
	print_conflicts();
}

void SLR1Builder::record_reduce(size_t state, const vector<int>& rules, size_t l)
{
	LRAction existing = LRAction::set_n(
							WhaleData::data.lr_automaton.states[state].action_table[l]);

	if (existing == LRAction::error() && rules.size() == 1)
		existing = LRAction::reduce(rules.front());
	else
		existing = process_lr_conflict(state, l,
				existing.is_shift() ? existing.shift_state() : -1,
				rules);
					
	WhaleData::data.lr_automaton.states[state].action_table[l] = existing.get_n();
}

void SLR1Builder::record_reduce(size_t state, size_t rule)
{
	vector<int> rules(1, int(rule));

	for (size_t i = 0; i < WhaleData::data.terminals.size(); ++i)
		record_reduce(state, rules, i);
}


void build_slr1_automaton()
{
	SLR1Builder builder;

	if (WhaleData::data.variables.dump_lr_automaton_to_file) {
	
		ofstream log((string(WhaleData::data.file_name) + ".lr0").c_str());
		log << "LR(0) automaton.\n";

		log << "(Only kernel items are shown)\n";
		for (size_t i = 0; i < builder.states.size(); ++i) {
			log << "State " << i << ".\n";
			log << "Kernel items: " << builder.states[i].rules << endl;
			log << "Reduces on rules : " << builder.states[i].reduces << endl;
			log << endl;			
		}
	}

}

