
/* An SLR(1) parser generated by Whale */

#ifndef __PARSER_GENERATED_BY_WHALE__PARSER_H

#define __PARSER_GENERATED_BY_WHALE__PARSER_H

#include <iostream>
#include <vector>

namespace Whale
{
	struct TerminalEOF;
	struct TerminalError;
	struct TerminalId;
	struct TerminalString;
	struct TerminalNumber;
	struct TerminalHexNumber;
	struct TerminalCode;
	struct TerminalArrow;
	struct TerminalSemicolon;
	struct TerminalScope;
	struct TerminalAssign;
	struct TerminalComma;
	struct TerminalSlash;
	struct TerminalColon;
	struct TerminalOr;
	struct TerminalAnd;
	struct TerminalNot;
	struct TerminalLeftParenthesis;
	struct TerminalRightParenthesis;
	struct TerminalLeftBracket;
	struct TerminalRightBracket;
	struct TerminalAsterisk;
	struct TerminalPlus;
	struct TerminalE;
	struct TerminalLessThan;
	struct TerminalGreaterThan;
	struct TerminalLessOrEqual;
	struct TerminalGreaterOrEqual;
	struct TerminalEqual;
	struct TerminalNotEqual;
	struct TerminalKwTerminal;
	struct TerminalKwNonterminal;
	struct TerminalKwExternal;
	struct TerminalKwClass;
	struct TerminalKwNothing;
	struct TerminalKwTrue;
	struct TerminalKwFalse;
	struct TerminalKwIterationPair;
	struct TerminalKwCreate;
	struct TerminalKwUpdate;
	struct TerminalKwConnectUp;
	struct TerminalKwPrecedence;
	
	struct NonterminalS;
	struct NonterminalTerminalStatement;
	struct NonterminalNonterminalStatement;
	struct NonterminalClassStatement;
	struct NonterminalRuleStatement;
	struct NonterminalPrecedenceStatement;
	struct NonterminalOptionStatement;
	struct NonterminalInvalidStatement;
	struct NonterminalTypeExpression;
	struct NonterminalExternalTypeExpression;
	struct NonterminalExternalTypeExpressionOne;
	struct NonterminalExternalTypeExpressionOneI;
	struct NonterminalExternalTypeExpressionOneII;
	struct NonterminalMemberExpression;
	struct NonterminalMemberExpressionNothing;
	struct NonterminalMemberExpressionInternal;
	struct NonterminalMemberExpressionExternal;
	struct NonterminalMemberExpressionBoth;
	struct NonterminalPrecedenceExpression;
	struct NonterminalExpression;
	struct NonterminalExpressionDisjunction;
	struct NonterminalExpressionConjunction;
	struct NonterminalExpressionConcatenation;
	struct NonterminalExpressionComplement;
	struct NonterminalExpressionOmittable;
	struct NonterminalExpressionInParentheses;
	struct NonterminalExpressionIteration;
	struct NonterminalExpressionIterationPair;
	struct NonterminalExpressionEpsilon;
	struct NonterminalExpressionSymbol;
	struct NonterminalExpressionMemberName;
	struct NonterminalExpressionCreate;
	struct NonterminalExpressionUpdate;
	struct NonterminalExpressionConnectUp;
	struct NonterminalExpressionCode;
	struct NonterminalExpressionPrecedence;
	struct Symbol
	{
		virtual bool is_terminal() const =0;
		virtual bool is_nonterminal() const =0;
	};
	struct Terminal : Symbol
	{
		int line, column;
		char *text;
		
		void print_location(std::ostream &os) const
		{
			os << "line " << line << " column " << column;
		}
		bool is_terminal() const { return true; }
		bool is_nonterminal() const { return false; }
		virtual int number() const =0;
	};
	struct Nonterminal : Symbol
	{
		bool is_terminal() const { return false; }
		bool is_nonterminal() const { return true; }
		virtual int number() const =0;
	};
	template<class Body> struct Iterator : Nonterminal
	{
		std::vector<Body *> body;
	};
	template<class BodyA, class BodyB> struct PairIterator : Nonterminal
	{
		std::vector<BodyA *> body_a;
		std::vector<BodyB *> body_b;
	};
	

} // namespace Whale

#include "lexical.h"


#include "whale.h"
#include "classes.h"


namespace Whale
{
	struct TerminalEOF : Terminal
	{
		int number() const { return 0; }
	};
	struct TerminalError : Terminal
	{
		int number() const { return 1; }
		
		std::vector<Symbol *> garbage;
		int error_position;
	};
	struct TerminalId : Terminal
	{
		int number() const { return 2; }
	};
	struct TerminalString : Terminal
	{
		int number() const { return 3; }
	};
	struct TerminalNumber : Terminal
	{
		int number() const { return 4; }
	};
	struct TerminalHexNumber : Terminal
	{
		int number() const { return 5; }
	};
	struct TerminalCode : Terminal
	{
		int number() const { return 6; }
	};
	struct TerminalArrow : Terminal
	{
		int number() const { return 7; }
	};
	struct TerminalSemicolon : Terminal
	{
		int number() const { return 8; }
	};
	struct TerminalScope : Terminal
	{
		int number() const { return 9; }
	};
	struct TerminalAssign : Terminal
	{
		int number() const { return 10; }
	};
	struct TerminalComma : Terminal
	{
		int number() const { return 11; }
	};
	struct TerminalSlash : Terminal
	{
		int number() const { return 12; }
	};
	struct TerminalColon : Terminal
	{
		int number() const { return 13; }
	};
	struct TerminalOr : Terminal
	{
		int number() const { return 14; }
	};
	struct TerminalAnd : Terminal
	{
		int number() const { return 15; }
	};
	struct TerminalNot : Terminal
	{
		int number() const { return 16; }
	};
	struct TerminalLeftParenthesis : Terminal
	{
		int number() const { return 17; }
	};
	struct TerminalRightParenthesis : Terminal
	{
		int number() const { return 18; }
	};
	struct TerminalLeftBracket : Terminal
	{
		int number() const { return 19; }
	};
	struct TerminalRightBracket : Terminal
	{
		int number() const { return 20; }
	};
	struct TerminalAsterisk : Terminal
	{
		int number() const { return 21; }
	};
	struct TerminalPlus : Terminal
	{
		int number() const { return 22; }
	};
	struct TerminalE : Terminal
	{
		int number() const { return 23; }
	};
	struct TerminalLessThan : Terminal
	{
		int number() const { return 24; }
	};
	struct TerminalGreaterThan : Terminal
	{
		int number() const { return 25; }
	};
	struct TerminalLessOrEqual : Terminal
	{
		int number() const { return 26; }
	};
	struct TerminalGreaterOrEqual : Terminal
	{
		int number() const { return 27; }
	};
	struct TerminalEqual : Terminal
	{
		int number() const { return 28; }
	};
	struct TerminalNotEqual : Terminal
	{
		int number() const { return 29; }
	};
	struct TerminalKwTerminal : Terminal
	{
		int number() const { return 30; }
	};
	struct TerminalKwNonterminal : Terminal
	{
		int number() const { return 31; }
	};
	struct TerminalKwExternal : Terminal
	{
		int number() const { return 32; }
	};
	struct TerminalKwClass : Terminal
	{
		int number() const { return 33; }
	};
	struct TerminalKwNothing : Terminal
	{
		int number() const { return 34; }
	};
	struct TerminalKwTrue : Terminal
	{
		int number() const { return 35; }
	};
	struct TerminalKwFalse : Terminal
	{
		int number() const { return 36; }
	};
	struct TerminalKwIterationPair : Terminal
	{
		int number() const { return 37; }
	};
	struct TerminalKwCreate : Terminal
	{
		int number() const { return 38; }
	};
	struct TerminalKwUpdate : Terminal
	{
		int number() const { return 39; }
	};
	struct TerminalKwConnectUp : Terminal
	{
		int number() const { return 40; }
	};
	struct TerminalKwPrecedence : Terminal
	{
		int number() const { return 41; }
	};
	
	struct NonterminalS : Nonterminal
	{
		struct BodyI : Nonterminal
		{
			int number() const { return 15; }
			
			Nonterminal *statements;
		};
		struct IteratorI : Iterator<NonterminalS::BodyI>
		{
			int number() const { return 16; }
		};
		
		int number() const { return 1; }
		
		std::vector<Nonterminal *> statements;
	};
	struct NonterminalTerminalStatement : Nonterminal
	{
		struct BodyIa : Nonterminal
		{
			int number() const { return 17; }
			
			Terminal *names;
			NonterminalTypeExpression *types;
			NonterminalExternalTypeExpression *external_types;
		};
		struct BodyIb : Nonterminal
		{
			int number() const { return 18; }
		};
		struct IteratorI : PairIterator<NonterminalTerminalStatement::BodyIa, NonterminalTerminalStatement::BodyIb>
		{
			int number() const { return 19; }
		};
		
		int number() const { return 2; }
		
		std::vector<Terminal *> names;
		std::vector<NonterminalTypeExpression *> types;
		std::vector<NonterminalExternalTypeExpression *> external_types;
	};
	struct NonterminalNonterminalStatement : Nonterminal
	{
		struct BodyIa : Nonterminal
		{
			int number() const { return 20; }
			
			TerminalId *names;
			NonterminalTypeExpression *internal_types;
			NonterminalExternalTypeExpression *external_types;
		};
		struct BodyIb : Nonterminal
		{
			int number() const { return 21; }
		};
		struct IteratorI : PairIterator<NonterminalNonterminalStatement::BodyIa, NonterminalNonterminalStatement::BodyIb>
		{
			int number() const { return 22; }
		};
		struct BodyIIa : Nonterminal
		{
			int number() const { return 23; }
			
			TerminalId *names;
			NonterminalExternalTypeExpression *external_types;
		};
		struct BodyIIb : Nonterminal
		{
			int number() const { return 24; }
		};
		struct IteratorII : PairIterator<NonterminalNonterminalStatement::BodyIIa, NonterminalNonterminalStatement::BodyIIb>
		{
			int number() const { return 25; }
		};
		
		int number() const { return 3; }
		
		Terminal *kw;
		std::vector<TerminalId *> names;
		std::vector<NonterminalTypeExpression *> internal_types;
		std::vector<NonterminalExternalTypeExpression *> external_types;
	};
	struct NonterminalClassStatement : Nonterminal
	{
		int number() const { return 4; }
		
		NonterminalTypeExpression *expr;
	};
	struct NonterminalRuleStatement : Nonterminal
	{
		int number() const { return 5; }
		
		TerminalId *left;
		NonterminalTypeExpression *type;
		TerminalArrow *arrow;
		NonterminalExpression *right;
	};
	struct NonterminalPrecedenceStatement : Nonterminal
	{
		struct BodyIa : Nonterminal
		{
			int number() const { return 26; }
			
			NonterminalPrecedenceExpression *expr;
		};
		struct BodyIb : Nonterminal
		{
			int number() const { return 27; }
		};
		struct IteratorI : PairIterator<NonterminalPrecedenceStatement::BodyIa, NonterminalPrecedenceStatement::BodyIb>
		{
			int number() const { return 28; }
		};
		
		int number() const { return 6; }
		
		std::vector<NonterminalPrecedenceExpression *> expr;
	};
	struct NonterminalOptionStatement : Nonterminal
	{
		struct BodyIa : Nonterminal
		{
			int number() const { return 29; }
			
			Terminal *middle;
		};
		struct BodyIb : Nonterminal
		{
			int number() const { return 30; }
		};
		struct IteratorI : PairIterator<NonterminalOptionStatement::BodyIa, NonterminalOptionStatement::BodyIb>
		{
			int number() const { return 31; }
		};
		struct BodyIIa : Nonterminal
		{
			int number() const { return 32; }
			
			Terminal *right;
		};
		struct BodyIIb : Nonterminal
		{
			int number() const { return 33; }
		};
		struct IteratorII : PairIterator<NonterminalOptionStatement::BodyIIa, NonterminalOptionStatement::BodyIIb>
		{
			int number() const { return 34; }
		};
		
		int number() const { return 7; }
		
		TerminalId *left;
		std::vector<Terminal *> middle;
		std::vector<Terminal *> right;
	};
	struct NonterminalInvalidStatement : Nonterminal
	{
		int number() const { return 8; }
	};
	struct NonterminalTypeExpression : Nonterminal
	{
		int number() const { return 9; }
		
		TerminalId *name;
		TerminalId *base_name;
	};
	struct NonterminalExternalTypeExpression : Nonterminal
	{
		struct BodyIa : Nonterminal
		{
			int number() const { return 35; }
			
			NonterminalExternalTypeExpression *template_arguments;
		};
		struct BodyIb : Nonterminal
		{
			int number() const { return 36; }
		};
		struct IteratorI : PairIterator<NonterminalExternalTypeExpression::BodyIa, NonterminalExternalTypeExpression::BodyIb>
		{
			int number() const { return 37; }
		};
		
		int number() const { return 10; }
		
		TerminalId *id;
		std::vector<NonterminalExternalTypeExpression *> template_arguments;
		NonterminalExternalTypeExpressionOne *expr1;
	};
	struct NonterminalExternalTypeExpressionOne : Nonterminal
	{
		struct BodyI : Nonterminal
		{
			int number() const { return 38; }
			
			TerminalAsterisk *asterisks;
		};
		struct IteratorI : Iterator<NonterminalExternalTypeExpressionOne::BodyI>
		{
			int number() const { return 39; }
		};
		
		int number() const { return 11; }
		virtual int alternative_number() const =0;
	};
	struct NonterminalExternalTypeExpressionOneI : NonterminalExternalTypeExpressionOne
	{
		int alternative_number() const { return 0; }
		
		std::vector<TerminalAsterisk *> asterisks;
		TerminalAnd *ampersand;
	};
	struct NonterminalExternalTypeExpressionOneII : NonterminalExternalTypeExpressionOne
	{
		int alternative_number() const { return 1; }
		
		NonterminalExternalTypeExpression *expr;
	};
	struct NonterminalMemberExpression : Nonterminal
	{
		int number() const { return 12; }
		virtual int alternative_number() const =0;
		
	bool is_nothing, i_specified, e_specified;
	Terminal *scope_i, *name_i;		// 'i' stands for internal,
	NonterminalExternalTypeExpression *type_e;
	Terminal *scope_e, *name_e;		// 'e' stands for external.
	Terminal *t;
	ClassHierarchy::DataMember *data_member_i, *data_member_e;
	int number_of_affected_symbols;
	NonterminalMemberExpression()
	{
		is_nothing=false, i_specified=false, e_specified=false;
		scope_i=NULL, name_i=NULL;
		type_e=NULL, scope_e=NULL, name_e=NULL;
		t=NULL;
		data_member_i=NULL, data_member_e=NULL;
		number_of_affected_symbols=0;
	}

	};
	struct NonterminalMemberExpressionNothing : NonterminalMemberExpression
	{
		int alternative_number() const { return 0; }
		
		TerminalKwNothing *kw;
	};
	struct NonterminalMemberExpressionInternal : NonterminalMemberExpression
	{
		int alternative_number() const { return 1; }
		
		TerminalId *scope;
		TerminalId *name;
	};
	struct NonterminalMemberExpressionExternal : NonterminalMemberExpression
	{
		int alternative_number() const { return 2; }
		
		NonterminalExternalTypeExpression *type;
		TerminalId *scope;
		TerminalId *name;
	};
	struct NonterminalMemberExpressionBoth : NonterminalMemberExpression
	{
		int alternative_number() const { return 3; }
		
		TerminalId *scope1;
		TerminalId *name1;
		NonterminalExternalTypeExpression *type2;
		TerminalId *scope2;
		TerminalId *name2;
	};
	struct NonterminalPrecedenceExpression : Nonterminal
	{
		struct BodyIa : Nonterminal
		{
			int number() const { return 40; }
			
			Terminal *operands;
			TerminalId *associativity;
		};
		struct BodyIb : Nonterminal
		{
			int number() const { return 41; }
			
			Terminal *comparison_operators;
		};
		struct IteratorI : PairIterator<NonterminalPrecedenceExpression::BodyIa, NonterminalPrecedenceExpression::BodyIb>
		{
			int number() const { return 42; }
		};
		
		int number() const { return 13; }
		
		std::vector<Terminal *> operands;
		std::vector<TerminalId *> associativity;
		std::vector<Terminal *> comparison_operators;
	};
	struct NonterminalExpression : Nonterminal
	{
		struct BodyIa : Nonterminal
		{
			int number() const { return 43; }
			
			Terminal *comparison_operators;
			Terminal *operands;
		};
		struct BodyIb : Nonterminal
		{
			int number() const { return 44; }
		};
		struct IteratorI : PairIterator<NonterminalExpression::BodyIa, NonterminalExpression::BodyIb>
		{
			int number() const { return 45; }
		};
		
		int number() const { return 14; }
		virtual int alternative_number() const =0;
	};
	struct NonterminalExpressionDisjunction : NonterminalExpression
	{
		int alternative_number() const { return 0; }
		
		NonterminalExpression *expr1;
		NonterminalExpression *expr2;
	};
	struct NonterminalExpressionConjunction : NonterminalExpression
	{
		int alternative_number() const { return 1; }
		
		NonterminalExpression *expr1;
		TerminalAnd *op;
		NonterminalExpression *expr2;
	};
	struct NonterminalExpressionConcatenation : NonterminalExpression
	{
		int alternative_number() const { return 2; }
		
		NonterminalExpression *expr1;
		NonterminalExpression *expr2;
	};
	struct NonterminalExpressionComplement : NonterminalExpression
	{
		int alternative_number() const { return 3; }
		
		TerminalNot *op;
		NonterminalExpression *expr;
	};
	struct NonterminalExpressionOmittable : NonterminalExpression
	{
		int alternative_number() const { return 4; }
		
		NonterminalExpression *expr;
	};
	struct NonterminalExpressionInParentheses : NonterminalExpression
	{
		int alternative_number() const { return 5; }
		
		NonterminalExpression *expr;
	};
	struct NonterminalExpressionIteration : NonterminalExpression
	{
		int alternative_number() const { return 6; }
		
		NonterminalExpression *expr;
		Terminal *sign;
		
	bool reflexive;
	int local_iterator_number;
	SymbolNumber body_sn;
	int iterator_nn;
	NonterminalExpressionIteration() : body_sn(SymbolNumber::error())
	{
	}

	};
	struct NonterminalExpressionIterationPair : NonterminalExpression
	{
		int alternative_number() const { return 7; }
		
		Terminal *kw;
		NonterminalExpression *expr1;
		NonterminalExpression *expr2;
		
	int local_iterator_number;
	SymbolNumber body1_sn, body2_sn;
	int iterator_nn;
	NonterminalExpressionIterationPair() : body1_sn(SymbolNumber::error()),
		body2_sn(SymbolNumber::error())
	{
	}

	};
	struct NonterminalExpressionEpsilon : NonterminalExpression
	{
		int alternative_number() const { return 8; }
	};
	struct NonterminalExpressionSymbol : NonterminalExpression
	{
		int alternative_number() const { return 9; }
		
		Terminal *symbol;
		
	SymbolNumber sn;
	ClassHierarchy::DataMember *data_member_i, *data_member_e; // both null means 'nothing'.
	int number_of_iterations;
	std::vector<ClassHierarchy::DataMember *> data_members_in_bodies; // [0] - the outer body
	NonterminalExpressionSymbol() : sn(SymbolNumber::error())
	{
		data_member_i=NULL;
		data_member_e=NULL;
	}

	};
	struct NonterminalExpressionMemberName : NonterminalExpression
	{
		int alternative_number() const { return 10; }
		
		NonterminalExpression *expr;
		NonterminalMemberExpression *expr_m;
	};
	struct NonterminalExpressionCreate : NonterminalExpression
	{
		int alternative_number() const { return 11; }
		
		TerminalKwCreate *kw;
		
	int local_creator_number;
	std::vector<int> creator_nn;

	};
	struct NonterminalExpressionUpdate : NonterminalExpression
	{
		int alternative_number() const { return 12; }
		
		TerminalKwUpdate *kw;
		
	int local_updater_number;
	std::vector<int> updater_nn;

	};
	struct NonterminalExpressionConnectUp : NonterminalExpression
	{
		int alternative_number() const { return 13; }
		
		TerminalKwConnectUp *kw;
		
	bool used_after_make_operator;

	};
	struct NonterminalExpressionCode : NonterminalExpression
	{
		int alternative_number() const { return 14; }
		
		TerminalCode *code;
		
	int invoker_nn;
	NonterminalExpressionCode() : invoker_nn(-1) {}

	};
	struct NonterminalExpressionPrecedence : NonterminalExpression
	{
		int alternative_number() const { return 15; }
		
		TerminalKwPrecedence *kw;
		std::vector<Terminal *> comparison_operators;
		std::vector<Terminal *> operands;
	};
	
	class Parser
	{
		static const char *whale_copyright_notice;
		
	public:
		static const int assumed_number_of_bits_in_int=32;
		static const int number_of_terminals=42;
		static const int number_of_nonterminals=46;
		static const int number_of_lr_states=249;
		static const int number_of_rules=144;
		static const int compressed_action_table_size=1218;
		static const int compressed_action_error_map_size=74;
		static const int compressed_goto_table_size=265;
		static const int eof_terminal_number=0;
		static const int error_terminal_number=1;
		
	protected:
		class LRAction
		{
			int n;
			
		public:
			LRAction(int supplied_n=0) { n=supplied_n; }
			
			bool is_error() const { return !n; }
			bool is_accept() const { return n==1; }
			bool is_shift() const { return n<0; }
			bool is_reduce() const { return n>=2; }
			int shift_state() const { return -n-1; }
			int reduce_rule() const { return n-1; }
			int get_n() const { return n; }
			static LRAction error() { return LRAction(0); }
			static LRAction accept() { return LRAction(1); }
			static LRAction shift(int state) { return LRAction(-state-1); }
			static LRAction reduce(int rule) { return LRAction(rule+1); }
		};
		struct StateData
		{
			bool sole_action;
			union { int index_in_action_table, action_value; };
			int index_in_action_error_map;
			int index_in_goto_table;
		};
		struct RuleData
		{
			int nn;
			int length;
		};
		
		static const StateData states[number_of_lr_states];
		static const RuleData rules[number_of_rules];
		static const int compressed_action_table[compressed_action_table_size];
		static const unsigned int compressed_action_error_map[compressed_action_error_map_size];
		static const int compressed_goto_table[compressed_goto_table_size];
		
	public:
		Parser(DolphinLexicalAnalyzer &lexical_analyzer_supplied) : lexical_analyzer(lexical_analyzer_supplied)
		{
			initialize();
		}
		void initialize();
		NonterminalS *parse();
		void report_error(std::ostream &os, const Terminal *t) const;
		bool recover_from_error();
		void print_stack(std::ostream &os) const;
		
	protected:
		DolphinLexicalAnalyzer &lexical_analyzer;
		Terminal *input_symbol;
		std::vector<int> state_stack;
		std::vector<Symbol *> symbol_stack;
		std::vector<Symbol *> garbage;
		
		LRAction access_action_table(int state, int tn) const
		{
			if(!access_error_map(compressed_action_error_map + states[state].index_in_action_error_map, tn))
				return LRAction::error();
			if(states[state].sole_action)
				return states[state].action_value;
			return LRAction(compressed_action_table[states[state].index_in_action_table+tn]);
		}
		bool access_error_map(const unsigned int *map, int n) const
		{
			return map[n/assumed_number_of_bits_in_int] & (1 << (n%assumed_number_of_bits_in_int));
		}
		int access_goto_table(int state, int nn) const
		{
			return compressed_goto_table[states[state].index_in_goto_table + nn];
		}
		int find_nonterminal_in_stack(int nn) const
		{
			for(int i=symbol_stack.size()-1; i>=0; i--)
				if(symbol_stack[i]->is_nonterminal())
				{
					Nonterminal *n=(Nonterminal *)symbol_stack[i];
					if(n->number()==nn)
						return i;
				}
			return -1;
		}
	};
	
	template<class T> std::vector<T> deepen(const T &x)
	{
		return std::vector<T>(1, x);
	}
	
	std::ostream &print_terminal_location(std::ostream &os, const Terminal *t);
	
} // namespace Whale

typedef Whale::Parser WhaleParser;

#endif
