/* Generated by re2c 1.1.1 on Tue Jul 28 22:35:58 2020 */
#line 1 "parseExpressionLex.re"
#include <float.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#ifdef _MSC_VER
#pragma warning(disable : 4703) // potentially uninitialized local pointer variable used.
#pragma warning(disable : 4701) // potentially uninitialized local variable used.
#pragma warning(push)
#endif
// to build: devtools\re2c-1.1.1\re2c.exe -T parseExpressionLex.re > parseExpressionLex.h

#line 13 "parseExpressionLex.re"

namespace expression_parser
{

template <int base>
static bool adddgt(unsigned int &u, unsigned int d)
{
  if (u > (ULONG_MAX - d) / base)
  {
    return false;
  }
  u = u * base + d;
  return true;
}

static bool lex_dec(const char *s, const char *e, unsigned int &u)
{
  for (u = 0; s < e; ++s)
  {
    if (!adddgt<10>(u, (unsigned char)(*s) - 0x30u))
    {
      return false;
    }
  }
  // printf("DEC %d ", u);
  return true;
}

static bool lex_flt(const char *s, float &d)
{
  d = 0;
  float x = 1;
  int e = 0;
#line 46 "parseExpressionLex.re"

mant_int:

#line 51 "<stdout>"
{
  char yych;
  yych = *s;
  switch (yych)
  {
    case '.': goto yy4;
    case 'E':
    case 'e': goto yy6;
    default: goto yy2;
  }
yy2:
  ++s;
#line 51 "parseExpressionLex.re"
  {
    d = (d * 10) + (s[-1] - '0');
    goto mant_int;
  }
#line 65 "<stdout>"
yy4:
  ++s;
#line 49 "parseExpressionLex.re"
  {
    goto mant_frac;
  }
#line 70 "<stdout>"
yy6:
  ++s;
#line 50 "parseExpressionLex.re"
  {
    goto exp_sign;
  }
#line 75 "<stdout>"
}
#line 52 "parseExpressionLex.re"

mant_frac:

#line 81 "<stdout>"
{
  char yych;
  yych = *s;
  switch (yych)
  {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto yy11;
    case 'E':
    case 'e': goto yy13;
    default: goto yy10;
  }
yy10:
#line 55 "parseExpressionLex.re"
{
  goto sfx;
}
#line 103 "<stdout>"
yy11:
  ++s;
#line 57 "parseExpressionLex.re"
  {
    d += (x /= 10) * (s[-1] - '0');
    goto mant_frac;
  }
#line 108 "<stdout>"
yy13:
  ++s;
#line 56 "parseExpressionLex.re"
  {
    goto exp_sign;
  }
#line 113 "<stdout>"
}
#line 58 "parseExpressionLex.re"

exp_sign:

#line 119 "<stdout>"
{
  char yych;
  yych = *s;
  switch (yych)
  {
    case '+': goto yy18;
    case '-': goto yy19;
    default: goto yy17;
  }
yy17:
#line 61 "parseExpressionLex.re"
{
  x = 1e+1;
  goto exp;
}
#line 131 "<stdout>"
yy18:
  ++s;
  goto yy17;
yy19:
  ++s;
#line 62 "parseExpressionLex.re"
  {
    x = 1e-1;
    goto exp;
  }
#line 139 "<stdout>"
}
#line 63 "parseExpressionLex.re"

exp:

#line 145 "<stdout>"
{
  char yych;
  yych = *s;
  switch (yych)
  {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto yy24;
    default: goto yy23;
  }
yy23:
#line 66 "parseExpressionLex.re"
{
  for (; e > 0; --e)
    d *= x;
  goto sfx;
}
#line 165 "<stdout>"
yy24:
  ++s;
#line 67 "parseExpressionLex.re"
  {
    e = (e * 10) + (s[-1] - '0');
    goto exp;
  }
#line 170 "<stdout>"
}
#line 68 "parseExpressionLex.re"

sfx:

#line 176 "<stdout>"
{
  char yych;
  yych = *s;
  switch (yych)
  {
    case 'F':
    case 'f': goto yy30;
    default: goto yy28;
  }
yy28:
  ++s;
#line 71 "parseExpressionLex.re"
  {
    goto end;
  }
#line 189 "<stdout>"
yy30:
  ++s;
#line 72 "parseExpressionLex.re"
  {
    if (d > FLT_MAX)
      return false;
    goto end;
  }
#line 194 "<stdout>"
}
#line 73 "parseExpressionLex.re"

end:
  return true;
}

enum TOKEN
{
  ERROR,
  END,
  COMMA,
  EFUN,
  ID,
  DEC,
  FLT,
  EID,
  BOOL,
  CMP_EQ,
  EQ,
  NE,
  LT,
  LE,
  GT,
  GE,
  AND,
  OR, // functions
  OPT
};

static const char *tokens[] = {
  "error!", "eof", ",", ")", "ident", "int", "flt", "eid", "bool", "==", "eq", "ne", "lt", "le", "gt", "ge", "and", "or", "opt"};

struct Token
{
  TOKEN token = ERROR;

  union
  {
    struct
    {
      const char *s, *e;
    } str; // for strings
    bool b;
    unsigned int u;
    int i;
    float f;
  } val;
  Token() = default;
  Token(TOKEN tok) { token = tok; }
  Token(const char *s, const char *e)
  {
    token = ID;
    val.str.s = s;
    val.str.e = e;
  }
  Token(bool b)
  {
    token = BOOL;
    val.b = b;
  }
  operator bool() const { return token != ERROR && token != END; }
};

static Token lex(const char *&s)
{
  const char *YYMARKER;
  const char *ds, *es, *ee, *fs, *is;
  Token error;
start:
  const char *yyt1;

#line 243 "<stdout>"
  {
    char yych;
    unsigned int yyaccept = 0;
    yych = *s;
    switch (yych)
    {
      case 0x00: goto yy34;
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy38;
      case ')': goto yy41;
      case ',': goto yy43;
      case '-': goto yy45;
      case '.': goto yy46;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': yyt1 = s; goto yy47;
      case '=': goto yy50;
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'b':
      case 'c':
      case 'd':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'm':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': yyt1 = s; goto yy51;
      case 'a': yyt1 = s; goto yy54;
      case 'e': yyt1 = s; goto yy55;
      case 'f': yyt1 = s; goto yy56;
      case 'g': yyt1 = s; goto yy57;
      case 'l': yyt1 = s; goto yy58;
      case 'n': yyt1 = s; goto yy59;
      case 'o': yyt1 = s; goto yy60;
      case 't': yyt1 = s; goto yy61;
      default: goto yy36;
    }
  yy34:
    ++s;
#line 125 "parseExpressionLex.re"
    {
      return Token(END);
    }
#line 349 "<stdout>"
  yy36:
    ++s;
  yy37:
#line 124 "parseExpressionLex.re"
  {
    return error;
  }
#line 355 "<stdout>"
  yy38:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy38;
      default: goto yy40;
    }
  yy40:
#line 129 "parseExpressionLex.re"
  {
    goto start;
  }
#line 369 "<stdout>"
  yy41:
    ++s;
#line 151 "parseExpressionLex.re"
    {
      return Token(EFUN);
    }
#line 374 "<stdout>"
  yy43:
    ++s;
#line 152 "parseExpressionLex.re"
    {
      return Token(COMMA);
    }
#line 379 "<stdout>"
  yy45:
    yyaccept = 0;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy62;
      case '.': yyt1 = s; goto yy65;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': yyt1 = s; goto yy66;
      default: goto yy37;
    }
  yy46:
    yych = *++s;
    switch (yych)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy69;
      default: goto yy37;
    }
  yy47:
    yyaccept = 1;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '.': goto yy69;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy47;
      case ':': goto yy72;
      case 'E':
      case 'e': goto yy73;
      default: goto yy49;
    }
  yy49:
    ds = yyt1;
#line 135 "parseExpressionLex.re"
    {
      Token tok(DEC);
      if (!lex_dec(ds, s, tok.val.u))
        return error;
      return tok;
    }
#line 445 "<stdout>"
  yy50:
    yych = *++s;
    switch (yych)
    {
      case '=': goto yy74;
      default: goto yy37;
    }
  yy51:
    yych = *++s;
  yy52:
    switch (yych)
    {
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': goto yy51;
      default: goto yy53;
    }
  yy53:
    is = yyt1;
#line 156 "parseExpressionLex.re"
    {
      return Token{is, s};
    }
#line 526 "<stdout>"
  yy54:
    yych = *++s;
    switch (yych)
    {
      case 'n': goto yy76;
      default: goto yy52;
    }
  yy55:
    yych = *++s;
    switch (yych)
    {
      case 'q': goto yy77;
      default: goto yy52;
    }
  yy56:
    yych = *++s;
    switch (yych)
    {
      case 'a': goto yy78;
      default: goto yy52;
    }
  yy57:
    yych = *++s;
    switch (yych)
    {
      case 'e': goto yy79;
      case 't': goto yy80;
      default: goto yy52;
    }
  yy58:
    yych = *++s;
    switch (yych)
    {
      case 'e': goto yy81;
      case 't': goto yy82;
      default: goto yy52;
    }
  yy59:
    yych = *++s;
    switch (yych)
    {
      case 'e': goto yy83;
      default: goto yy52;
    }
  yy60:
    yych = *++s;
    switch (yych)
    {
      case 'p': goto yy84;
      case 'r': goto yy85;
      default: goto yy52;
    }
  yy61:
    yych = *++s;
    switch (yych)
    {
      case 'r': goto yy86;
      default: goto yy52;
    }
  yy62:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy62;
      case '.': yyt1 = s; goto yy65;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': yyt1 = s; goto yy66;
      default: goto yy64;
    }
  yy64:
    s = YYMARKER;
    switch (yyaccept)
    {
      case 0: goto yy37;
      case 1: goto yy49;
      case 2: goto yy68;
      case 3: goto yy71;
      case 4: goto yy53;
      default: goto yy89;
    }
  yy65:
    yych = *++s;
    switch (yych)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy87;
      default: goto yy64;
    }
  yy66:
    yyaccept = 2;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '.': goto yy87;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy66;
      case 'E':
      case 'e': goto yy90;
      default: goto yy68;
    }
  yy68:
    ds = yyt1;
#line 136 "parseExpressionLex.re"
    {
      Token tok(DEC);
      if (!lex_dec(ds, s, tok.val.u))
        return error;
      tok.val.i = -tok.val.i;
      return tok;
    }
#line 651 "<stdout>"
  yy69:
    yyaccept = 3;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy69;
      case 'E':
      case 'e': goto yy73;
      case 'F':
      case 'L':
      case 'f':
      case 'l': goto yy91;
      default: goto yy71;
    }
  yy71:
#line 143 "parseExpressionLex.re"
  {
    Token tok(FLT);
    if (!lex_flt(s, tok.val.f))
      return error;
    return tok;
  }
#line 677 "<stdout>"
  yy72:
    yych = *++s;
    switch (yych)
    {
      case 'e': goto yy92;
      default: goto yy64;
    }
  yy73:
    yych = *++s;
    switch (yych)
    {
      case '+':
      case '-': goto yy93;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy94;
      default: goto yy64;
    }
  yy74:
    ++s;
#line 168 "parseExpressionLex.re"
    {
      return Token(CMP_EQ);
    }
#line 705 "<stdout>"
  yy76:
    yych = *++s;
    switch (yych)
    {
      case 'd': goto yy96;
      default: goto yy52;
    }
  yy77:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy97;
      case '(': goto yy99;
      default: goto yy52;
    }
  yy78:
    yych = *++s;
    switch (yych)
    {
      case 'l': goto yy101;
      default: goto yy52;
    }
  yy79:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy102;
      case '(': goto yy104;
      default: goto yy52;
    }
  yy80:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy106;
      case '(': goto yy108;
      default: goto yy52;
    }
  yy81:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy110;
      case '(': goto yy112;
      default: goto yy52;
    }
  yy82:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy114;
      case '(': goto yy116;
      default: goto yy52;
    }
  yy83:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy118;
      case '(': goto yy120;
      default: goto yy52;
    }
  yy84:
    yych = *++s;
    switch (yych)
    {
      case 't': goto yy122;
      default: goto yy52;
    }
  yy85:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy123;
      case '(': goto yy125;
      default: goto yy52;
    }
  yy86:
    yych = *++s;
    switch (yych)
    {
      case 'u': goto yy127;
      default: goto yy52;
    }
  yy87:
    yyaccept = 5;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy87;
      case 'E':
      case 'e': goto yy90;
      case 'F':
      case 'L':
      case 'f':
      case 'l': goto yy128;
      default: goto yy89;
    }
  yy89:
    fs = yyt1;
#line 144 "parseExpressionLex.re"
    {
      Token tok(FLT);
      if (!lex_flt(fs, tok.val.f))
        return error;
      tok.val.f = -tok.val.f;
      return tok;
    }
#line 840 "<stdout>"
  yy90:
    yych = *++s;
    switch (yych)
    {
      case '+':
      case '-': goto yy129;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy130;
      default: goto yy64;
    }
  yy91:
    ++s;
    goto yy71;
  yy92:
    yych = *++s;
    switch (yych)
    {
      case 'i': goto yy132;
      default: goto yy64;
    }
  yy93:
    yych = *++s;
    switch (yych)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy94;
      default: goto yy64;
    }
  yy94:
    yych = *++s;
    switch (yych)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy94;
      case 'F':
      case 'L':
      case 'f':
      case 'l': goto yy91;
      default: goto yy71;
    }
  yy96:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy133;
      case '(': goto yy135;
      default: goto yy52;
    }
  yy97:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy97;
      case '(': goto yy99;
      default: goto yy64;
    }
  yy99:
    ++s;
#line 167 "parseExpressionLex.re"
    {
      return Token(EQ);
    }
#line 928 "<stdout>"
  yy101:
    yych = *++s;
    switch (yych)
    {
      case 's': goto yy137;
      default: goto yy52;
    }
  yy102:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy102;
      case '(': goto yy104;
      default: goto yy64;
    }
  yy104:
    ++s;
#line 173 "parseExpressionLex.re"
    {
      return Token(GE);
    }
#line 950 "<stdout>"
  yy106:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy106;
      case '(': goto yy108;
      default: goto yy64;
    }
  yy108:
    ++s;
#line 172 "parseExpressionLex.re"
    {
      return Token(GT);
    }
#line 966 "<stdout>"
  yy110:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy110;
      case '(': goto yy112;
      default: goto yy64;
    }
  yy112:
    ++s;
#line 171 "parseExpressionLex.re"
    {
      return Token(LE);
    }
#line 982 "<stdout>"
  yy114:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy114;
      case '(': goto yy116;
      default: goto yy64;
    }
  yy116:
    ++s;
#line 170 "parseExpressionLex.re"
    {
      return Token(LT);
    }
#line 998 "<stdout>"
  yy118:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy118;
      case '(': goto yy120;
      default: goto yy64;
    }
  yy120:
    ++s;
#line 169 "parseExpressionLex.re"
    {
      return Token(NE);
    }
#line 1014 "<stdout>"
  yy122:
    yyaccept = 4;
    yych = *(YYMARKER = ++s);
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy138;
      case '(': goto yy140;
      default: goto yy52;
    }
  yy123:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy123;
      case '(': goto yy125;
      default: goto yy64;
    }
  yy125:
    ++s;
#line 175 "parseExpressionLex.re"
    {
      return Token(OR);
    }
#line 1042 "<stdout>"
  yy127:
    yych = *++s;
    switch (yych)
    {
      case 'e': goto yy142;
      default: goto yy52;
    }
  yy128:
    ++s;
    goto yy89;
  yy129:
    yych = *++s;
    switch (yych)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy130;
      default: goto yy64;
    }
  yy130:
    yych = *++s;
    switch (yych)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': goto yy130;
      case 'F':
      case 'L':
      case 'f':
      case 'l': goto yy128;
      default: goto yy89;
    }
  yy132:
    yych = *++s;
    switch (yych)
    {
      case 'd': goto yy144;
      default: goto yy64;
    }
  yy133:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy133;
      case '(': goto yy135;
      default: goto yy64;
    }
  yy135:
    ++s;
#line 174 "parseExpressionLex.re"
    {
      return Token(AND);
    }
#line 1107 "<stdout>"
  yy137:
    yych = *++s;
    switch (yych)
    {
      case 'e': goto yy146;
      default: goto yy52;
    }
  yy138:
    yych = *++s;
    switch (yych)
    {
      case '\t':
      case '\n':
      case '\v':
      case '\r':
      case ' ': goto yy138;
      case '(': goto yy140;
      default: goto yy64;
    }
  yy140:
    ++s;
#line 176 "parseExpressionLex.re"
    {
      return Token(OPT);
    }
#line 1129 "<stdout>"
  yy142:
    yych = *++s;
    switch (yych)
    {
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': goto yy51;
      default: goto yy143;
    }
  yy143:
#line 148 "parseExpressionLex.re"
  {
    return Token(true);
  }
#line 1202 "<stdout>"
  yy144:
    ++s;
    es = yyt1;
    ee = s - 4;
#line 137 "parseExpressionLex.re"
    {
      Token tok(EID);
      if (!lex_dec(es, ee, tok.val.u))
        return error;
      return tok;
    }
#line 1209 "<stdout>"
  yy146:
    yych = *++s;
    switch (yych)
    {
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z': goto yy51;
      default: goto yy147;
    }
  yy147:
#line 147 "parseExpressionLex.re"
  {
    return Token(false);
  }
#line 1282 "<stdout>"
  }
#line 177 "parseExpressionLex.re"
}

} // namespace expression_parser
#ifdef _MSC_VER
#pragma warning(pop)
#endif
